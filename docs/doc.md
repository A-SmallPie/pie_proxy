代理要实现如下功能
    - 多种负载均衡算法
    - 故障转移
    - 识别新启动的节点并迅速投入到使用中

服务端工作流程：
    收到客户端请求，ac连接后在工作线程池里面挑出来一个线程处理这个连接
    工作线程拿到这个连接后把它放到epoll监听列表里面
    如果某个连接有数据要传epoll就会提醒，此时工作线程处理消息

代理层可以先用nigx顶上

单一共享任务队列的本质就是抢任务，这种方式可能导致很多线程拿不到任务
但是会有一些线程能够拿到大量任务，所以这不是一个非常好的方法
    解决方法
    (1) 主线程按照某种规则直接向线程独享任务（隐式）队列投放任务，每个线程只从自己的队列里面取任务
    (2) 每个线程都独享一个任务队列，实现线程之间相互偷任务，如果自己的队列里面没有任务，就去别的线程的任务队列里偷一个。
    这种方式能够实现自动均衡，适合处理高并发，并且每个任务处理时间长短不一的情况。这种方式也需要主线程的初始分配策略
        - 窃取任务的时候可能需要作无锁窃取， 这样更牛逼!
        - 注意偷任务是队列的行为，不是线程的行为！线程只管做好服务端处理逻辑就好了

如果要拿一个类对象的成员函数做回调函数，必须用移动语义
    当回调捕获了类的成员（如this指针或unique_ptr）时：
       1. 直接赋值会复制整个回调对象，包括其捕获的资源指针
       2. 如果捕获的是unique_ptr，会因复制而编译失败
       3. 如果捕获的是普通指针，可能造成：
          - 重复释放（当多个回调实例尝试delete同一指针）
          - 竞争访问（当多线程同时通过指针访问资源）
       使用std::move转移所有权，确保任何时候：
       - 只有一个回调实例持有资源访问权
       - 原回调变量失效，防止意外使用
    使用 std::move 的两种关键作用：
       1. 所有权转移：明确该回调将由其存储对象(event_callback_)独占，
          原调用方不得再使用此回调，避免:
          - 资源竞争（多份回调同时操作）
          - 生命周期混乱（原调用方可能已析构）
       2. 强制独占性：当回调捕获了不可拷贝的资源（如unique_ptr）时，
          移动是唯一合法传递方式（拷贝会直接编译失败


为什么需要连接池？
​问题1：回调里不能直接删对象
    当客户端连接出错时，需要：
    关掉socket（close(fd)）
    从epoll移除监听（epoll_ctl(..., EPOLL_CTL_DEL, fd, ...)）
    最后才能删掉这个连接对象（delete this）
    ​坑：如果直接在回调函数里delete this，但回调后面还有代码没执行完，程序就崩了！

​问题2：延迟删除很麻烦
    试过用should_destroy_标记，等后面再删
    但这样要维护一个全局列表，工作线程还得定期检查哪些连接要删，​又慢又难写。

​问题3：频繁new/delete很亏
    每次来新连接都new Connection()，断开又delete，​内存碎片多，速度还慢。

问题4：没法直接改任务队列：
    我的任务队列是完全用来放主线程分配的新连接的，这样也方便偷数据
    但是如果任务队列改成了别的，在连接类上再包装一层任务，偷任务的时候就得判断能不能偷，太麻烦了


​2. 连接池怎么解决这些问题？
​核心思想：
    ​连接对象用完不删，留着下次复用​（像租充电宝，还回去还能再借）
    ​删对象由主线程统一管，工作线程只“还”不“删”
    这样还能解除子线程管理连接的耦合（主线程创建连接， 子线程销毁连接， 这样不太好）
​具体操作：
    ​初始化时：预先创建一堆连接对象，放在池子里（比如100个）。
    ​有新连接时：从池子里借一个对象，初始化它的socket和epoll监听。
​连接出错时：
    工作线程关socket、清空数据，​把对象还回池子​（不删！）
    ​主线程定期清理：如果池子里对象太多（比如超过200个），主线程删掉一些。