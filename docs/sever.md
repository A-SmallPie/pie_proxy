服务端开发文档

服务端现有的逻辑：
    主线程ac连接，创建连接对象交给线程池里面的线程，（放在线程专用的连接队列里面），线程从连接队列里面取出来连接对象加入epoll监听，连接类处理手法数据等操作，连接类如果发现需要关闭连接，会通过工作线程的回调函数通知工作线程关闭fd，移除监听，但是不知道怎么销毁连接对象自身

初版设计目标：
    主线程ac连接，交给连接池里面的工作线程处理
    工作线程每个线程都有一个epoll实例管理连接（初期没有代理，直接管理客户端连接）

设计目标迭代第一次：
    主线程怎么把连接交给工作线程处理？答：任务队列
    设计任务队列，主线程把ac的fd放在任务队列，工作线程在任务队列里抢任务

设计目标迭代第二次：
    工作线程抢任务，势必会因为频繁加锁解锁造成巨大性能开销，不好
    改成每个工作线程独享任务队列，这样还能方便后期实现线程之间的偷任务，实现服务端自动负载均衡

设计目标迭代第三次：
    工作线程没法获取建立连接的客户端信息
    添加连接的包装，在封装的连接类里面取得信息
    并且将工作线程处理客户端信息的逻辑转移到连接类里面

设计目标迭代第四次：
    连接类发现需要关闭连接，但是不知道在那里销毁自身，因为在这个回调里绝对不能直接销毁调用回调的这个对象，所以只能设计连接池，连接类需要关闭连接的时候通过回调通知工作线程取消监听fd并关闭fd，然后将连接对象归还连接池。连接池统一销毁连接类

设计目标迭代第五次：
    因为服务端必须使用连接池，而且需要避免双重池花，所以服务端不能用连接池了，需要其他方法让连接类销毁自身。（用智能指针/RAII很容易就能实现，但是我暂时不想用）
    在连接类上再套一层，实现类：任务，连接队列改称任务队列，连接类发现需要关闭连接的时候通知工作线程移除连接，并把销毁连接的任务插入到任务队列
    工作线程每次循环弹出来k个任务

设计目标迭代第六次：
    连接类调用回调来延迟销毁自身的方式无法使用，因为连接是主线程调用的，但是连接类的回调方法是属于工作线程的，连接类在创建的时候不知道自己会被分配给哪个工作线程，所以无法初始化连接类(可以由工作线程负责补全回调函数)，这次只能考虑使用智能指针了。（为啥不想用智能指针：想体验以下有智能指针之前是怎么管理连接类的生命周期的，目前看来可以使用连接池延迟销毁， 可以直接向连接类的任务队列投递销毁自身的任务也可以，但是必须确保连接类和工作线程位于一个线程，如果这个任务在刚加入到任务队列里就被其他工作线程偷走了，直接把这个连接类给销毁了，这样连接类剩下的代码就会出错）

设计目标迭代第七次
    每个工作线程可以有两个工作队列，一个专属队列存放本线程专属任务（线程关闭请求），一个共享队列存放可以偷的任务（新连接的分配）
    期间遇到头文件包含问题，可以在hpp文件里使用前向声明，在源文件里包含头文件，或者使用头文件保护，ifdef或者#p once

设计目标迭代第八次:
    connection的生命周期还是用shared_ptr管理最好，可以弄一个连接管理器，需要关闭连接的时候直接remove掉fd对应的连接类对象
    这样连接类就不需要保存管理自身的线程的任务队列了，但是需要保存连接管理器(连接管理器可以由主线程管理也可以由工作线程管理)的引用/指针。
    这样连接类需要关闭自身的时候直接remove掉自身在连接管理器map里面的映射，使自身的引用-1，然后通知工作线程移除fd的监听，最后关闭fd就可以完成生命周期管理
    或者先通知移除epoll监听，然后让连接管理器关闭fd，移除fd映射，这样连接类对象代码执行完后类自己马上就会自动销毁
    （如果连接管理器由主线程持有会不会增加负担？是否需要在连接管理器里面集成一个小对象池？连接管理器如果由主线程管理势必会带来锁的开销，可以考虑无锁队列）
    （但是感觉还是主线程瓶颈更加紧迫，一台机子只有主线程的qps上去了，才能更好的利用子线程）
    如果连接管理器给主线程，主线程就可以实现谁创建，谁销毁的原则，或者也可以通过只传fd让子线程创建连接类对象，然后每个子线程都有一个连接管理器（这是一种完全去中心化的方案）

设计目标迭代第九次:
    任务类采用带枚举类型的结构体还是太死板了，执行任务的逻辑全都要放在工作线程里面，这会显得工作线程非常臃肿且难以维护，比较好的方法是使用多态实现任务对象，所有任务类继承自基础任务类，任务类的执行逻辑写在任务类的统一方法里
    这种设计会带来一些问题：
        多态额外的开销，首先是如果用指针管理任务类，调用任务的成本就有寻址+虚函数表查找+栈操作，
        线程持有的资源管理问题：工作线程类里面几乎要实现所有持有资源的操作接口，这也会大幅度增加工作线程的复杂度，这也违反工作线程只负责任务处理，不关心处理逻辑的设计原则。
        任务执行函数与线程之间的资源访问问题：如果任务类执行的时候需要访问工作线程持有的资源，比如插入新任务，通知工作线程移除epoll监听，移除连接，销毁连接对象等
    最终采用的解决方法：
        虚函数表开销问题：CRTP模板类，在编译期就知道要调用哪个函数，从而省去虚函数表的查找时间。
        资源管理问题：为方便统一管理所有资源，把线程持有的所有资源封装成一个类，在这个类里面实现所有资源的操作接口，资源类实现的操作接口都是透传原始资源操作接口，调用该接口和调用原始资源的操作接口所花费的时间是完全一样的
        资源访问问题：工作线程在调用任务的execute函数的时候会给任务类提供工作线程持有的资源（上述资源类的引用）
    基于上述改进，连接类的生命周期管理也能够进一步迭代，在任务/连接类代码执行的过程中如果发现需要关闭自身，可以直接调用资源类里面的连接管理器的移除连接方法，连接类使用共享指针管理，移除连接类后，计数-1，连接类代码执行完毕后会自动销毁。也可以选择直接操作对应的接口立即完成自销毁。
    这样，工作线程可以完全专注于自身的逻辑，根本不用考虑个个任务是怎么作的，只需要调用execute函数就可以了。

设计方面已经基本完成，接下来需要完善未实现的功能：数据发送逻辑，心跳机制，任务窃取机制，无锁任务队列，连接管理器的线程安全操作（需要吗）

5.22日细节完善：
    数据发送逻辑：为什么接收的时候需要分片接收，发送的时候却最好是直接一次性发送？
    TCP是流式协议，不知道数据边界在哪里，所以只能一点一点收，稍加思索，也能明白为什么要约定一个固定的数据边界。
    发送的时候内核会自动分片，如果没发送完，会返回已经发送的字节数，需要单独处理没发送的数据，还没发送的数据存放在缓冲区里面，已经发送的数据需要定时清理
    已经发送的数据在逻辑上删除即可，否则会增加内存拷贝开销，当缓冲区增长到一定程度把未发送数据的头部移动到缓冲区的头部
    或者使用环形缓冲区，完全避免拷贝开销


服务端的最难点：
    连接类的生命周期管理：谁创建？谁销毁？谁管理？如何管理？
    背景：每个子线程都有一个独享的任务队列/独享epoll实例/后期需要扩展偷任务功能自动均衡负载（偷任务可以用双队列实现无锁/少锁双端队列）
    方案1：主线程ac连接，创建连接类对象由移交给子线程
        分支1：子线程接收到连接类对象后给他设置一个回调，连接类对象发现自己需要销毁时通过回调通知工作线程进行销毁的一系列工作（延迟销毁：通过任务队列或者连接池）
        分支2：子线程收到连接类对象后给他自己的任务队列引用，连接类对象发现自己需要销毁的时候直接向任务队列插入销毁毁任务（无回调）
        分支3：主作线程有一个连接管理器，用共享指针管理连接对象，主线程创建连接对象的时候给他自己的连接管理器指针，连接类对象发现自己需要销毁的时候直接remove掉连接管理器里面的fd-connection对，连接类对象代码执行完后自动销毁（这种方法可能会加重主线程负担，比如锁竞争什么的）
            子分支1：通过任务队列通知主线程移除监听
            子分支2：通过回调通知主线程移除监听
        分支4：工作线程有一个独享连接管理器，用共享指针管理连接对象，子线程收到连接类对象后给他自己的连接管理器，连接类对象发现自己需要销毁的时候直接向工作线程提交销毁任务（只需closefd和移除epoll监听，连接类对象代码执行完后自动销毁）
    方案2：主线程直接分发ac好的裸fd，子线程负责创建连接类对象
        分支1：子线程收到fd创建对象，提供其所需的信息。连接类发现需关闭的时候通过任务队列/连接管理器销毁自身。***最终采纳***


任务类设计：
    原始代码所有的任务执行逻辑都写在工作线程里面，比较优雅的方案是把任务执行逻辑写在任务类里面，但是这样任务类怎么访问工作线程持有的资源呢（如epoll实例）
    主线程/工作线程向任务队列里面投递任务，任务执行前向任务对象注入资源上下文
    将epoll实例和任务队列注册为线程的局部变量，这个线程的其他类都能访问，但是其他线程怎么访问？（其他线程没法访问）

任务执行设计：
    工作线程每次尝试弹出一个任务对象都需要加锁和解锁操作
    工作线程怎么连续在队列中连续弹出多个任务而避免多次加锁解锁操作

现在存在的问题：
    连接类发现自己需要关闭后，会直接往任务队列里插入删除自身的任务，但是到真正删除是有一定延迟的，这时候如果有新的事件被监听到，会出大问题。
    所以需要启用is_closed标志位
    连接类需要新加入一个绑定的event对象，但是连接类初始化需要event，而event又需要设置绑定的连接类对象
    可以传过去一个不完整的event对象，然后在构造函数里面初始化没初始化的部分

最终迭代目标：
    类型擦除，零拷贝（移动语义），低开销，线程安全, 可扩展，实现无锁队列，实现超级性能！

