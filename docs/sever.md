服务端开发文档

服务端现有的逻辑：
    主线程ac连接，创建连接对象交给线程池里面的线程，（放在线程专用的连接队列里面），线程从连接队列里面取出来连接对象加入epoll监听，连接类处理手法数据等操作，连接类如果发现需要关闭连接，会通过工作线程的回调函数通知工作线程关闭fd，移除监听，但是不知道怎么销毁连接对象自身

初版设计目标：
    主线程ac连接，交给连接池里面的工作线程处理
    工作线程每个线程都有一个epoll实例管理连接（初期没有代理，直接管理客户端连接）

设计目标迭代第一次：
    主线程怎么把连接交给工作线程处理？答：任务队列
    设计任务队列，主线程把ac的fd放在任务队列，工作线程在任务队列里抢任务

设计目标迭代第二次：
    工作线程抢任务，势必会因为频繁加锁解锁造成巨大性能开销，不好
    改成每个工作线程独享任务队列，这样还能方便后期实现线程之间的偷任务，实现服务端自动负载均衡

设计目标迭代第三次：
    工作线程没法获取建立连接的客户端信息
    添加连接的包装，在封装的连接类里面取得信息
    并且将工作线程处理客户端信息的逻辑转移到连接类里面

设计目标迭代第四次：
    连接类发现需要关闭连接，但是不知道在那里销毁自身，因为在这个回调里绝对不能直接销毁调用回调的这个对象，所以只能设计连接池，连接类需要关闭连接的时候通过回调通知工作线程取消监听fd并关闭fd，然后将连接对象归还连接池。连接池统一销毁连接类

设计目标迭代第五次：
    因为服务端必须使用连接池，而且需要避免双重池花，所以服务端不能用连接池了，需要其他方法让连接类销毁自身。（用智能指针/RAII很容易就能实现，但是我暂时不想用）
    在连接类上再套一层，实现类：任务，连接队列改称任务队列，连接类发现需要关闭连接的时候通知工作线程移除连接，并把销毁连接的任务插入到任务队列
    工作线程每次循环弹出来k个任务

设计目标迭代第六次：
    连接类调用回调来延迟销毁自身的方式无法使用，因为连接是主线程调用的，但是连接类的回调方法是属于工作线程的，连接类在创建的时候不知道自己会被分配给哪个工作线程，所以无法初始化连接类(可以由工作线程负责补全回调函数)，这次只能考虑使用智能指针了。（为啥不想用智能指针：想体验以下有智能指针之前是怎么管理连接类的生命周期的，目前看来可以使用连接池延迟销毁， 可以直接向连接类的任务队列投递销毁自身的任务也可以，但是必须确保连接类和工作线程位于一个线程，如果这个任务在刚加入到任务队列里就被其他工作线程偷走了，直接把这个连接类给销毁了，这样连接类剩下的代码就会出错）

设计目标迭代第七次
    每个工作线程可以有两个工作队列，一个专属队列存放本线程专属任务（线程关闭请求），一个共享队列存放可以偷的任务（新连接的分配）
    期间遇到头文件包含问题，可以在hpp文件里使用前向声明，在源文件里包含头文件，或者使用头文件保护，ifdef或者#p once

设计目标迭代第八次:
    connection的生命周期还是用shared_ptr管理最好，可以弄一个连接管理器，需要关闭连接的时候直接remove掉fd对应的连接类对象
    这样连接类就不需要保存管理自身的线程的任务队列了，但是需要保存连接管理器(连接管理器可以由主线程管理也可以由工作线程管理)的引用/指针。
    这样连接类需要关闭自身的时候直接remove掉自身在连接管理器map里面的映射，使自身的引用-1，然后通知工作线程移除fd的监听，最后关闭fd就可以完成生命周期管理
    或者先通知移除epoll监听，然后让连接管理器关闭fd，移除fd映射，这样连接类对象代码执行完后类自己马上就会自动销毁
    （如果连接管理器由主线程持有会不会增加负担？是否需要在连接管理器里面集成一个小对象池？连接管理器如果由主线程管理势必会带来锁的开销，可以考虑无锁队列）
    （但是感觉还是主线程瓶颈更加紧迫，一台机子只有主线程的qps上去了，才能更好的利用子线程）
    如果连接管理器给主线程，主线程就可以实现谁创建，谁销毁的原则，或者也可以通过只传fd让子线程创建连接类对象，然后每个子线程都有一个连接管理器（这是一种完全去中心化的方案）


服务端的最难点：
    连接类的生命周期管理：谁创建？谁销毁？谁管理？如何管理？
    背景：每个子线程都有一个独享的任务队列/独享epoll实例/后期需要扩展偷任务功能自动均衡负载（偷任务可以用双队列实现无锁/少锁双端队列）
    方案1：主线程ac连接，创建连接类对象由移交给子线程
        分支1：子线程接收到连接类对象后给他设置一个回调，连接类对象发现自己需要销毁时通过回调通知工作线程进行销毁的一系列工作（延迟销毁：通过任务队列或者连接池）
        分支2：子线程收到连接类对象后给他自己的任务队列引用，连接类对象发现自己需要销毁的时候直接向任务队列插入销毁毁任务（无回调）
        分支3：主作线程有一个连接管理器，用共享指针管理连接对象，主线程创建连接对象的时候给他自己的连接管理器指针，连接类对象发现自己需要销毁的时候直接remove掉连接管理器里面的fd-connection对，连接类对象代码执行完后自动销毁（这种方法可能会加重主线程负担，比如锁竞争什么的）
            子分支1：通过任务队列通知主线程移除监听
            子分支2：通过回调通知主线程移除监听
        分支4：工作线程有一个独享连接管理器，用共享指针管理连接对象，子线程收到连接类对象后给他自己的连接管理器，连接类对象发现自己需要销毁的时候直接向工作线程提交销毁任务（只需closefd和移除epoll监听，连接类对象代码执行完后自动销毁）
    方案2：主线程直接分发ac好的裸fd，子线程负责创建连接类对象
        分支1：子线程收到fd创建对象，提供其所需的信息。连接类发现需关闭的时候通过任务队列/连接管理器销毁自身。***最终采纳***


任务类设计：
    原始代码所有的任务执行逻辑都写在工作线程里面，比较优雅的方案是把任务执行逻辑写在任务类里面，但是这样任务类怎么访问工作线程持有的资源呢（如epoll实例）
    主线程/工作线程向任务队列里面投递任务，任务执行前向任务对象注入资源上下文
    将epoll实例和任务队列注册为线程的局部变量，这个线程的其他类都能访问，但是其他线程怎么访问？（其他线程没法访问）

任务执行设计：
    工作线程每次尝试弹出一个任务对象都需要加锁和解锁操作
    工作线程怎么连续在队列中连续弹出多个任务而避免多次加锁解锁操作

现在存在的问题：
    连接类发现自己需要关闭后，会直接往任务队列里插入删除自身的任务，但是到真正删除是有一定延迟的，这时候如果有新的事件被监听到，会出大问题。
    所以需要启用is_closed标志位

最终迭代目标：
    类型擦除，零拷贝（移动语义），低开销，线程安全, 可扩展，实现无锁队列，实现超级性能！

