# pie_proxy
A high-performance C++ network proxy framework based on epoll and the Reactor pattern, designed for scalability and efficiency.

目标:
1.实现TCP echo服务器
2.扩展为单向代理
3.完成双向代理
4.添加多后端支持+简单的轮询负载均衡算法
5.集成json配置解析
6.添加日志系统
7.压力测试优化
升级版目标:
1.健康检查, 定时ping后端服务器, 自动踢出故障节点
2.一致性哈希算法, 替代轮询, 实现会话保持
3.实现基于线程池的多线程版本
4.包装客户端连接
5.实现对象池管理连接, 实现O(1)的对象获取与归还
6.服务端实现任务窃取自动平衡负载
7.支持协议切换

为什么选择Epoll
1.高效的事件通知, 值返回就绪的文件描述符
2.O(1)的时间复杂度, 性能不随着连接数的增加而下降
3.内存友好, 不需要每次都传递所有监控的fd集合

为什么epoll高效
1.不是轮询, epoll不会主动检查所有fd, 而是内核通知那些fd就绪
2.事件驱动, 只有我们关心的事件才会得到通知
3.高效原因: 通过内核回调机制避免无所谓的遍历
4.两种触发方式
(1)水平触发(LT): 只要文件描述符就绪就会通知
(2)边缘触发(ET): 只在状态变化时通知一次(需要应用程序处理所有可用数据, 性能高但是变成更加复杂)
(3)一次性触发: 事件被处理后直接禁用该文件描述符, 需要注册才能重新监听


服务端如何实现同时服务多个客户端的目标:
1.基础版本: 多进程, 分出来一个进程服务一个客户端
2.多线程: 主进程负责accept, 线程用来处理新连接(可以使用线程池来提升性能)
3.IO多路复用: 单进程的高效解决方案(epoll)
4.异步IO, 编程复杂但是性能最好
5.混合模型: 
(1)多线程+IO多路复用, 每个线程维护一个epoll循环 
(2)多进程+每个进程使用IO多路复用, ngix使用的方法.